<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chat Example</title>
    <script type="text/javascript">
      window.onload = function () {
        var cacheTable = []; //this is a really, REALLY basic caching table, that tells the renderer when converting addresses from log to regular, what to skip over by value
        var conn;
        var msg = document.getElementById("rawsource"); //the raw, markdown source
        var log = document.getElementById("log"); //the visible source to the user
        // function cursorUpdated(selectionStart,selectionEnd) {
        //     if (!conn) {
        //         return false;
        //     }
        //     conn.send([selectionStart,selectionEnd]);
        //     return false;
        // }
        function checkCached(address) {
          //checks the character location to see if it's cached
          for (let i = 0; i < cacheTable.length; i += 2) {
            if (cacheTable[i] === address) {
              return true;
            }
          }
          return false;
        }
        function render() {
          //welcome to the crackhead zone
          //this is a VERY small proof of concept of our renderer, the real deal will be more than just this ofc
          //renders to the log, but only at the specified index in the text, and only how much was told to be rendered, and removes any user typed code as well
          //or at least, thats what its gonna do when its done, for now it just renders the whole document
          const text = msg.innerText;
          log.innerHTML = "";
          const split = text.split("\n");
          let textCache = "";
          let componentCache = "";
          let element = null;
          // console.log(text.length + " " + split.length)

          for (let i = 0; i < split.length; i++) {
            //this runs for every line of the innertext
            //implement this code based on https://www.markdownguide.org/cheat-sheet/
            //here is the basic idea that I had:
            //textcache works as the cache for text, wherein all text that is written to be added to the document is written there
            //component cache is used while working on making an element: say for example you're writing a <a>, then during the step where the url is being written,
            //the <a>'s url is stored in componentcache, before being finished and actually being added to the element which is made and stored in element
            // console.log(split[i].length)
            let skip = false; //if true, we skip this char during parsing, and treat it as a normal char
            let mode = 0; //this is the character mode setter, and depending on the setting, we parse in a few different ways:
            // 0 - Run normally, append characters if need be, but other than that we chillin
            // 1 - We are in text mod mode, open a span and wait for a span to end here because this is just basic text editing stuff
            // 2 - We are in URL mode and in particular are setting the URL's name during creation
            // 3 - We are in URL mode and in particular are setting the URL's URL during creation
            // 4 - We are in widget mode and awaiting a second $ to generate the widget
            // 5 - We are in Style mode, but otherwise are writing normal text
            // 6 - unusued
            // 7 - unusued
            // 8 - unusued
            // 9 - unusued
            // 10 - We are in Image mode and in particular are setting the Image's alt-text during creation
            // 11 - We are in Image mode and in particular are setting the Image's URL during creation
            // 12 - unusued
            // 13 - unusued
            // 14 - We are in checkbox mode and awaiting closure

            let styleByte = 0; //style is handled effectively as a very small bitwise int, and we just handle that as is
            //00000000
            //IBMSMWHU
            //I - Italic 7
            //B - Bold 6
            //M - Code 5
            //S - Strikethrough 4
            //M - Subscript 3
            //W - Superscript 2
            //H - Highlight 1
            //U - Underline 0
            for (let a = 0; a < split[i].length; a++) {
              console.log("Mode: " + mode)
              //this runs for every char of a list and basically, we're gonna iterate on this
              if (!skip) {
                switch (
                  split[i].charAt(a) //switch over the chars, we doin basic char detection time boys
                ) {
                  case "\\":
                    {
                      console.log("skipping next char")
                      //if we backslash, then skip the next character in parsing
                      skip = true;
                    }
                    break;
                  case "@":
                    {
                      if (split[i].charAt(a + 1) == "{") {
                        mode = 1;
                      } else {
                        if (mode == 0) {
                          textCache += "@";
                        } else {
                          componentCache += "@";
                        }
                      }
                    }
                    break;
                  case "[":
                    {
                      if (mode == 0) {
                        // console.log(split[i].charAt(a+1))
                        if (
                          split[i].charAt(a + 1) == "!" ||
                          split[i].charAt(a + 1) == " "
                        ) {
                          // console.log("checkbox")
                          mode = 14;
                          element = document.createElement("input");
                          element.setAttribute("type", "checkbox");
                          element.setAttribute("name", "checkbox");

                          if (split[i].charAt(a + 1) == "!") {
                            element.setAttribute("checked", "true");
                          }
                        } else {
                          // console.log("link")
                          mode = 2;
                          element = document.createElement("a");
                        }
                      }
                    }
                    break;
                  case "]":
                    {
                      switch (mode) {
                        case 14:
                          {
                            mode = 0;
                            textCache += element.outerHTML;
                            componentCache = "";
                          }
                          break;
                        case 2: {
                          mode = 3;
                          // console.log(componentCache)
                          element.innerText = componentCache;
                          componentCache = "";
                          a++;
                        }
                      }
                    }
                    break;
                  case ")":
                    {
                      //since there is no case where the letter "(" is parsed, we can basically just skip it and treat it as a normal char
                      switch (mode) {
                        case 3:
                          {
                            mode = 0;
                            element.setAttribute("href", componentCache);
                            textCache += element.outerHTML;
                            componentCache = "";
                            // console.log(componentCache)
                          }
                          break;
                      }
                    }
                    break;
                  case "*":
                    //for the folks at home confused, here's a quick breakdown of this lil equation: styleByte>>6&1
                    //tldr; styleByte is our byte described above, and we shift it right 6 times, 
                    //such that the 7th bit is the last bit in the byte, 
                    //and then AND it by 1 to make sure it's equal to 1 to determine if that bit is enabled or disabled.
                    //We could just hardcode the AND values here, but in favor of ease of reading, i won't do that lol
                    //its basic chemistry
                      if(split[i].charAt(a+1) == '*' && !(styleByte>>6&1)) { //if the next character is a star, and bit 6 of the styleByte is NOT set to 1
                        componentCache+="<strong>"
                        styleByte = styleByte^(1<<6);
                        a++; //add, so that we avoid parsing the next *
                      }
                      else if(!(styleByte>>7&1) && split[i].charAt(a+1) != '*') {
                        componentCache+="<i>"
                          styleByte = styleByte^(1<<7);
                      }
                      else {
                        if((styleByte>>7&1) && split[i].charAt(a+1) != '*') {
                          componentCache+="</i>"
                          styleByte = styleByte^(1<<7);
                        }
                        else if(split[i].charAt(a+1) == '*' && styleByte>>6&1) {
                          componentCache+="</strong>"
                          styleByte = styleByte^(1<<6);
                          a++; //add, so that we avoid parsing the next *

                        }
                        if( styleByte == 0) {

                          styleByte = 0;
                          textCache += componentCache;
                          componentCache = "";
                        }
                      }
                      
                    // } else if (mode == 5) {
                    //   mode = 0; // Exit italic mode
                    //   element.innerText = componentCache; // Set italic text content
                    //   textCache += element.outerHTML; // Add the <i> tag and content to the textCache
                    //   componentCache = ""; // Clear component cache for future use
                    // }
                    break;
                  case '~':{
                    if(split[i].charAt(a+1) == '~' && !(styleByte>>4&1)) { //if the next character is a star, and bit 6 of the styleByte is NOT set to 1
                        componentCache+="<s>"
                        styleByte = styleByte^(1<<4);
                        a++; //add, so that we avoid parsing the next *
                      }
                      else if(!(styleByte>>3&1) && split[i].charAt(a+1) != '~') {
                        componentCache+="<sup>"
                          styleByte = styleByte^(1<<3);
                      }
                      else {
                        if((styleByte>>3&1) && split[i].charAt(a+1) != '~') {
                          componentCache+="</sup>"
                          styleByte = styleByte^(1<<3);
                        }
                        else if(split[i].charAt(a+1) == '~' && styleByte>>4&1) {
                          componentCache+="</s>"
                          styleByte = styleByte^(1<<4);
                          a++; //add, so that we avoid parsing the next *

                        }
                        if( styleByte == 0) {

                          styleByte = 0;
                          textCache += componentCache;
                          componentCache = "";
                        }
                      }

                  }break;
                  case '`':{
                    if(!(styleByte>>5&1)) { //if the next character is a ~, and bit 4 of the styleByte is NOT set to 1
                        componentCache+="<code>"
                        styleByte = styleByte^(1<<5);
                        a++; //add, so that we avoid parsing the next ~
                      }
                      else {
                        if(styleByte>>5&1) {
                          componentCache+="</code>"
                          styleByte = styleByte^(1<<5);
                          a++; //add, so that we avoid parsing the next *

                        }
                        if( styleByte == 0) {
                          styleByte = 0;
                          textCache += componentCache;
                          componentCache = "";
                        }
                      }
                  }break;
                  case '=':{
                    if(split[i].charAt(a+1) == '=' && !(styleByte>>1&1)) { //if the next character is a ~, and bit 4 of the styleByte is NOT set to 1
                        componentCache+="<span class=\"highlight\">"
                        styleByte = styleByte^(1<<1);
                        a++; //add, so that we avoid parsing the next ~
                      }
                      else {
                        if(split[i].charAt(a+1) == '=' && styleByte>>1&1) {
                          componentCache+="</span>"
                          styleByte = styleByte^(1<<1);
                          a++; //add, so that we avoid parsing the next *

                        }
                        if( styleByte == 0) {
                          styleByte = 0;
                          textCache += componentCache;
                          componentCache = "";
                        }
                      }
                  }break;
                  case '^':{
                    if(!(styleByte>>2&1)) { //if the next character is a ~, and bit 4 of the styleByte is NOT set to 1
                        componentCache+="<sub>"
                        styleByte = styleByte^(1<<2);
                      }
                      else {
                        if(styleByte>>2&1) {
                          componentCache+="</sub>"
                          styleByte = styleByte^(1<<2);

                        }
                        if( styleByte == 0) {
                          styleByte = 0;
                          textCache += componentCache;
                          componentCache = "";
                        }
                      }
                  }break;
                  case '_':{
                    if(split[i].charAt(a+1) == '_' && !(styleByte>>0&1)) { //if the next character is a star, and bit 6 of the styleByte is NOT set to 1
                        componentCache+="<u>"
                        styleByte = styleByte^(1<<0);
                        a++; //add, so that we avoid parsing the next *
                      }
                      else {
                        if(split[i].charAt(a+1) == '_' && styleByte>>0&1) {
                          componentCache+="</s>"
                          styleByte = styleByte^(1<<0);
                          a++; //add, so that we avoid parsing the next *

                        }
                        if( styleByte == 0) {

                          styleByte = 0;
                          textCache += componentCache;
                          componentCache = "";
                        }
                      }

                  }break;

                  default:
                    {
                      if (mode <= 0 && styleByte == 0) {
                        textCache += split[i].charAt(a);
                        console.log("typing " + split[i].charAt(a))

                      } else {
                        console.log("componenting " + split[i].charAt(a))
                        componentCache += split[i].charAt(a);
                      }
                    }
                    break;
                }
                // log.innerHTML += split[i].charAt(a);
              } else {
                if (mode == 0 && styleByte == 0) {
                    textCache += split[i].charAt(a);

                  } else {
                    console.log("componenting " + split[i].charAt(a))
                    componentCache += split[i].charAt(a);
                  }
                  skip=false;
              }
            }
            textCache += "<br>";
          }
          log.innerHTML = textCache;
        }
        // document.getElementById("form").onsubmit = function () {
        //     if (!conn) {
        //         return false;
        //     }
        //     if (!msg.value) {
        //         return false;
        //     }
        //     conn.send(msg.value);
        //     msg.value = "";
        //     return false;
        // };
        log.addEventListener("keydown", (e) => {
          render();
          // const selection = window.getSelection();
          // let ranges = [];

          // for (let i = 0; i < selection.rangeCount; i++) {
          //     selecteditem = selection.getRangeAt(i);
          //     console.log(selecteditem.commonAncestorContainer.nodeName);
          // }
          // const range = selection.getRangeAt(0);
          // console.log(getPosition(e.target));
          // // Check if the selection contains a span
          // // if (range.commonAncestorContainer.tagName.toLowerCase() === 'span') {
          //     // Expand the selection to include the entire span
          //     // range.setStartBefore(range.commonAncestorContainer);
          //     // range.setEndAfter(range.commonAncestorContainer);
          //     // selection.removeAllRanges();
          //     // selection.addRange(range);
          // // }

          // // Process the normalized selection (e.g., get the selected text, apply formatting)
          // const selectedText = selection.toString();
          // console.log(selectedText);
          // // cursorUpdated(selRange.startOffset,selRange.startOffset)
        });
        log.addEventListener("mouseup", (e) => {
          // cursorUpdated(e.target.selectionStart,e.target.selectionEnd)
        });
        // if (window["WebSocket"]) {
        //     conn = new WebSocket("ws://" + document.location.host + "/ws");
        //     conn.onclose = function (evt) {
        //     };
        //     conn.onmessage = function (evt) {
        //         var messages = evt.data;
        //         console.log(messages)
        //     };
        // } else {
        //     var item = document.createElement("div");
        //     item.innerHTML = "<b>Your browser does not support WebSockets.</b>";
        //     appendLog(item);
        // }
      };
    </script>
    <style type="text/css">
      html {
        overflow: hidden;
      }

      body {
        overflow: hidden;
        padding: 0;
        margin: 0;
        width: 100%;
        height: 100%;
        background: gray;
      }

      #log {
        background: white;
        margin: 0;
        padding: 0.5em 0.5em 0.5em 0.5em;
        position: absolute;
        top: 0.5em;
        left: 0.5em;
        right: 0.5em;
        bottom: 3em;
        overflow: auto;
        resize: none;
      }

      #form {
        padding: 0 0.5em 0 0.5em;
        margin: 0;
        position: absolute;
        bottom: 1em;
        left: 0px;
        width: 100%;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <div id="rawsource" style="white-space: pre">
      Hello **world**!
      *this is a test, so see if **mixed stuff** works, if at all...*
      How about ***bold and italic*** together?
      **this is a *sentence* that tests a few things**
      \*\*\*this shouldnt be bold\*\*\*
      **what if we give it **dumb stupid code** that shouldnt work?**\*
      If you want to draw a textbox, you can do it **like this**
      [!] Checked! \[!\]
      [ ] Unchecked \[ \]

      But hey, what if you want a link?
      [DOWNLOAD MORE RAM \(FREE\)\!\!\!](https://example.com)
      
      Woooooooah dude, howd you do that????
      Oh, it's actually pretty easy:
      \[DOWNLOAD MORE RAM \\(FREE\\\)\\!\\!\\!\]\(https://example.com\)
      x^2^ or x~2~ i dont ~~understand either way~~ but hey, __thats **OKAY**__
      <!-- I *think* that this code is working, but **IM NOT SURE.** -->
    </div>
    <div id="log" contenteditable="true"></div>
  </body>
</html>
